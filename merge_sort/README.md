# مفهوم مرتب‌سازی ادغامی (Merge Sort)

مرتب‌سازی ادغامی یک الگوریتم مرتب‌سازی کلاسیک است که بر اساس روش تقسیم و غلبه (divide-and-conquer) کار می‌کند و کارآمد و آسان برای درک است. در اینجا یک مرور جامع از الگوریتم مرتب‌سازی ادغامی شامل مفهوم، پیاده‌سازی و تحلیل آن آورده شده است.

# مراحل مرتب‌سازی ادغامی

1. **تقسیم (Divide):** آرایه به دو نیمه تقسیم می‌شود.
2. **غلبه (Conquer):** هر نیمه به‌طور بازگشتی مرتب می‌شود.
3. **ادغام (Combine):** دو نیمه مرتب‌شده دوباره به هم ادغام می‌شوند تا یک آرایه مرتب‌شده واحد تولید شود.

# مراحل مرتب‌سازی ادغامی

1. اگر آرایه یک یا صفر عنصر داشته باشد، از قبل مرتب شده است.
2. آرایه به دو نیمه تقسیم می‌شود.
3. الگوریتم مرتب‌سازی ادغامی به‌طور بازگشتی به هر دو نیمه اعمال می‌شود.
4. دو نیمه مرتب‌شده به یک آرایه مرتب‌شده واحد ادغام می‌شوند.

# مثال

فرض کنید می‌خواهیم آرایه زیر را مرتب کنیم: `[38, 27, 43, 3, 9, 82, 10]`.

1. **تقسیم:**
   - به دو نیمه تقسیم می‌شود: `[38, 27, 43]` و `[3, 9, 82, 10]`.

2. **غلبه:**
   - نیمه اول `[38, 27, 43]` را مرتب می‌کنیم:
     - به `[38]` و `[27, 43]` تقسیم می‌شود.
     - `[27, 43]` را مرتب می‌کنیم → به `[27]` و `[43]` تقسیم می‌شود، که از قبل مرتب هستند و سپس دوباره ادغام می‌شوند تا `[27, 43]` به‌دست آید.
     - `[38]` و `[27, 43]` را ادغام می‌کنیم تا `[27, 38, 43]` به‌دست آید.
   - نیمه دوم `[3, 9, 82, 10]` را مرتب می‌کنیم:
     - به `[3, 9]` و `[82, 10]` تقسیم می‌شود.
     - `[3, 9]` → از قبل مرتب است.
     - `[82, 10]` → به `[82]` و `[10]` تقسیم می‌شود و با هم ادغام می‌شوند تا `[10, 82]` به‌دست آید.
     - `[3, 9]` و `[10, 82]` را ادغام می‌کنیم تا `[3, 9, 10, 82]` به‌دست آید.

3. **ادغام:**
   - دو نیمه مرتب‌شده `[27, 38, 43]` و `[3, 9, 10, 82]` را ادغام می‌کنیم:
   - آرایه مرتب نهایی `[3, 9, 10, 27, 38, 43, 82]` است.

# پیاده‌سازی

در اینجا نحوه پیاده‌سازی مرتب‌سازی ادغامی در پایتون آورده شده است:

```python
def merge_sort(arr):
    if len(arr) <= 1:
        return arr

    mid = len(arr) // 2
    left_half = merge_sort(arr[:mid])
    right_half = merge_sort(arr[mid:])

    return merge(left_half, right_half)

def merge(left, right):
    sorted_array = []
    i = j = 0

    # ادغام دو نیمه به یک آرایه مرتب
    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            sorted_array.append(left[i])
            i += 1
        else:
            sorted_array.append(right[j])
            j += 1

    # اگر عناصری در سمت چپ یا راست باقی مانده باشد، آنها را اضافه کن
    sorted_array.extend(left[i:])
    sorted_array.extend(right[j:])

    return sorted_array

# مثال استفاده
arr = [38, 27, 43, 3, 9, 82, 10]
sorted_arr = merge_sort(arr)
print("آرایه مرتب شده:", sorted_arr)
```

#  مرتبه اجرایی

- **بهترین حالت:** O(n log n)
- **حالت متوسط:** O(n log n)
- **بدترین حالت:** O(n log n)

# تحلیل فضا

- O(n) به دلیل آرایه‌های موقتی که در فرایند ادغام استفاده می‌شوند.

# مزایای مرتب‌سازی ادغامی

- **پایدار:** ترتیب عناصر برابر را حفظ می‌کند.
- **قابل پیش‌بینی:** پیچیدگی زمانی همیشه O(n log n) است.
- **خوب برای مجموعه‌های داده بزرگ:** به ویژه با لیست‌های پیوندی یا زمانی که داده‌ها در حافظه جا نمی‌شوند.

# معایب مرتب‌سازی ادغامی

- **پیچیدگی فضای:** نیاز به فضای اضافی متناسب با اندازه آرایه دارد.
- **کندتر برای مجموعه‌های داده کوچک:** برای مجموعه‌های داده کوچک، الگوریتم‌های ساده‌تری مانند مرتب‌سازی درج (Insertion Sort) ممکن است سریع‌تر باشند.

# نتیجه‌گیری

مرتب‌سازی ادغامی یک الگوریتم قدرتمند است که به‌طور کارآمد مجموعه‌های داده بزرگ را با پیچیدگی زمانی تضمینی O(n log n) مرتب می‌کند. این الگوریتم به‌ویژه در موقعیت‌هایی که پایداری مورد نیاز است یا هنگام کار با لیست‌های پیوندی مفید است. با درک رویکرد تقسیم و غلبه، می‌توانید مرتب‌سازی ادغامی را به‌طور مؤثر پیاده‌سازی و در سناریوهای مختلف برنامه‌نویسی به‌کار ببرید.
